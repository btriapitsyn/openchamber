import React, { useMemo, useRef, useEffect, useState } from 'react';
import { AnimatedMarkdown } from 'flowtoken';
import 'flowtoken/dist/styles.css';
import type { Part } from '@opencode-ai/sdk';

interface StreamingAnimatedTextProps {
    content: string;
    isStreaming: boolean;
    markdownComponents: any;
    part?: Part; // Add part info to access time data
    messageCompleted?: boolean; // Add message completion status
}

export const StreamingAnimatedText: React.FC<StreamingAnimatedTextProps> = ({
    content,
    isStreaming,
    markdownComponents,
    part,
    messageCompleted = false
}) => {
    // Minimal refs to avoid conflicts with FlowToken's internal tracking
    const prevContentRef = useRef(content);

    // Enhanced logic: stop animation when content stops growing
    const [lastContentLength, setLastContentLength] = useState(content.length);
    const [lastContentChangeTime, setLastContentChangeTime] = useState(Date.now());
    const [animationShouldStop, setAnimationShouldStop] = useState(false);

    // Track content changes
    useEffect(() => {
        if (content.length > lastContentLength) {
            // Content is growing - update tracking
            setLastContentLength(content.length);
            setLastContentChangeTime(Date.now());
            setAnimationShouldStop(false);
        }
    }, [content.length, lastContentLength]);

    // Auto-stop animation when content stops growing
    useEffect(() => {
        if (isStreaming && content.length > 0) {
            const timeout = setTimeout(() => {
                // If content hasn't grown in 2 seconds, stop animation
                const timeSinceLastChange = Date.now() - lastContentChangeTime;
                if (timeSinceLastChange >= 2000) {
                    setAnimationShouldStop(true);
                }
            }, 2000);

            return () => clearTimeout(timeout);
        }
    }, [isStreaming, lastContentChangeTime, content.length]);

    // Reset animation state when starting new streaming
    useEffect(() => {
        if (isStreaming && content.length === 0) {
            setAnimationShouldStop(false);
            setLastContentLength(0);
            setLastContentChangeTime(Date.now());
        }
    }, [isStreaming, content.length]);

    const shouldAnimate = useMemo(() => {
        // Don't animate if we determined it should stop
        if (animationShouldStop) return false;

        // Don't animate if message is complete
        if (messageCompleted) return false;

        // Don't animate if part is complete
        if (part && 'time' in part && part.time?.end) return false;

        // Animate if streaming and animation hasn't been stopped
        return isStreaming;
    }, [isStreaming, messageCompleted, part, animationShouldStop]);

    // Minimal content tracking for debugging
    useEffect(() => {
        prevContentRef.current = content;
    }, [content]);

    // Clean up the content to avoid issues
    const cleanedContent = useMemo(() => {
        return content.replace(/<[^>]*$/g, '');
    }, [content]);

    // Use ultra-stable key that never changes during part lifecycle
    // This is CRITICAL for FlowToken's internal state preservation
    const componentKey = useMemo(() => {
        // Once we have a part ID, lock it forever for this component instance
        if (part?.id) return `flow-${part.id}`;
        // Fallback for parts without ID - still stable
        return 'flow-default';
    }, [part?.id]);

    // DEBUG: Test if FlowToken works at all
    const debugMode = true; // Set to true for testing

    if (debugMode) {
        return (
            <div className="break-words">
                {/* Show debug info */}
                <div style={{ fontSize: '10px', color: 'red', marginBottom: '4px' }}>
                    DEBUG: isStreaming={isStreaming ? 'true' : 'false'}, shouldAnimate={shouldAnimate ? 'true' : 'false'}, contentLength={content.length}, animationShouldStop={animationShouldStop ? 'true' : 'false'}, timeSinceChange={Math.round((Date.now() - lastContentChangeTime) / 1000)}s
                </div>

                <AnimatedMarkdown
                    key={componentKey}
                    content={cleanedContent}
                    sep="word" // Try word instead of diff
                    animation={shouldAnimate ? "fadeIn" : null} // Only when shouldAnimate is true
                    animationDuration="2s"
                    animationTimingFunction="ease-out"
                    customComponents={markdownComponents}
                />
            </div>
        );
    }

    return (
        <div className="break-words">
            <AnimatedMarkdown
                key={componentKey}
                content={cleanedContent}
                sep="diff"
                animation={shouldAnimate ? 'fadeIn' : null}
                animationDuration="2s"
                animationTimingFunction="ease-out"
                customComponents={markdownComponents}
            />
        </div>
    );
};
