{
  "generatedAt": "2025-10-12T10:33:51Z",
  "basePath": "/api",
  "types": {
    "HealthStatus": {
      "kind": "interface",
      "ts": "export interface HealthStatus { status: 'ok' | 'error'; timestamp: string; openCodePort: number | null; openCodeRunning: boolean; openCodeApiPrefix: string; openCodeApiPrefixDetected: boolean; isOpenCodeReady: boolean; lastOpenCodeError: string | null; }",
      "notes": "Used by system.getHealth."
    },
    "ModelsMetadata": {
      "kind": "type",
      "ts": "export type ModelsMetadata = Record<string, unknown>;",
      "notes": "Pass-through models.dev payload."
    },
    "AgentSourceSummary": {
      "kind": "interface",
      "ts": "export interface AgentSourceSummary { name: string; sources: { md: { exists: boolean; path: string | null; fields: string[] }; json: { exists: boolean; path: string; fields: string[] } }; isBuiltIn: boolean; }",
      "notes": "Returned by config.getAgent."
    },
    "AgentWritePayload": {
      "kind": "interface",
      "ts": "export interface AgentWritePayload { prompt?: string; [key: string]: unknown; }",
      "notes": "Frontmatter fields accepted; prompt stored as markdown body."
    },
    "CommandSourceSummary": {
      "kind": "interface",
      "ts": "export interface CommandSourceSummary { name: string; sources: { md: { exists: boolean; path: string | null; fields: string[] }; json: { exists: boolean; path: string; fields: string[] } }; isBuiltIn: boolean; }",
      "notes": "Returned by config.getCommand."
    },
    "CommandWritePayload": {
      "kind": "interface",
      "ts": "export interface CommandWritePayload { template?: string; [key: string]: unknown; }",
      "notes": "Fields mirroring opencode command definition."
    },
    "ReloadResponse": {
      "kind": "interface",
      "ts": "export interface ReloadResponse { success: boolean; requiresReload: boolean; message: string; reloadDelayMs: number; }",
      "notes": "Common success payload for config mutations."
    },
    "GitIdentity": {
      "kind": "interface",
      "ts": "export interface GitIdentity { id: string; name: string; userName: string; userEmail: string; sshKey: string | null; color: string; icon: string; }",
      "notes": "Stored in ~/.config/opencode-webui/git-identities.json."
    },
    "GitIdentityWritePayload": {
      "kind": "interface",
      "ts": "export interface GitIdentityWritePayload { id: string; name?: string; userName: string; userEmail: string; sshKey?: string | null; color?: string; icon?: string; }",
      "notes": "Used for create."
    },
    "GitIdentityUpdatePayload": {
      "kind": "interface",
      "ts": "export interface GitIdentityUpdatePayload { name?: string; userName?: string; userEmail?: string; sshKey?: string | null; color?: string; icon?: string; }",
      "notes": "Used for update; id immutable."
    },
    "GitIdentityApplyPayload": {
      "kind": "interface",
      "ts": "export interface GitIdentityApplyPayload { profileId: string; }",
      "notes": "Used for git.setIdentity body."
    },
    "GitDirectoryQuery": {
      "kind": "interface",
      "ts": "export interface GitDirectoryQuery { directory: string; }",
      "notes": "Shared query param definition."
    },
    "GitStatus": {
      "kind": "interface",
      "ts": "export interface GitStatus { current: string | null; tracking: string | null; ahead: number; behind: number; files: { path: string; index: string; working_dir: string; }[]; isClean: boolean; }",
      "notes": "Result of git.getStatus."
    },
    "GitRemoteOptions": {
      "kind": "type",
      "ts": "export type GitRemoteOptions = Record<string, unknown>;",
      "notes": "Passed through to simple-git for pull/push/fetch."
    },
    "GitCommitPayload": {
      "kind": "interface",
      "ts": "export interface GitCommitPayload { message: string; addAll?: boolean; }",
      "notes": "Payload for git.commit."
    },
    "GitBranchCreatePayload": {
      "kind": "interface",
      "ts": "export interface GitBranchCreatePayload { name: string; startPoint?: string; }",
      "notes": "Body for git.createBranch."
    },
    "GitCheckoutPayload": {
      "kind": "interface",
      "ts": "export interface GitCheckoutPayload { branch: string; }",
      "notes": "Body for git.checkoutBranch."
    },
    "GitWorktreeCreatePayload": {
      "kind": "interface",
      "ts": "export interface GitWorktreeCreatePayload { path: string; branch: string; createBranch?: boolean; }",
      "notes": "Body for git.addWorktree."
    },
    "GitWorktreeRemovePayload": {
      "kind": "interface",
      "ts": "export interface GitWorktreeRemovePayload { path: string; force?: boolean; }",
      "notes": "Body for git.removeWorktree."
    },
    "GitWorktreeEntry": {
      "kind": "interface",
      "ts": "export interface GitWorktreeEntry { worktree: string; head?: string; branch?: string; }",
      "notes": "Returned by git.listWorktrees."
    },
    "GitLogQuery": {
      "kind": "interface",
      "ts": "export interface GitLogQuery { directory: string; maxCount?: number; from?: string; to?: string; file?: string; }",
      "notes": "Query parameters for git.getLog."
    },
    "GitLogResponse": {
      "kind": "interface",
      "ts": "export interface GitLogResponse { all: Record<string, unknown>[]; latest: Record<string, unknown> | null; total: number; }",
      "notes": "Pass-through from simple-git log result."
    },
    "MkdirPayload": {
      "kind": "interface",
      "ts": "export interface MkdirPayload { path: string; }",
      "notes": "Body for fs.mkdir."
    },
    "GenericSuccess": {
      "kind": "interface",
      "ts": "export interface GenericSuccess { success: boolean; message?: string; [key: string]: unknown; }",
      "notes": "Used by theme deletions and similar responses."
    }
  },
  "methods": [
    {
      "name": "system.getHealth",
      "tauriInvoke": "system_get_health",
      "category": "system",
      "priority": "high",
      "http": {
        "method": "GET",
        "path": "/health"
      },
      "input": null,
      "output": "HealthStatus",
      "errorCases": [
        {
          "status": 500,
          "description": "Unexpected server failure"
        }
      ],
      "notes": "Poll every 5s in desktop shell to reflect OpenCode readiness."
    },
    {
      "name": "webui.getModelsMetadata",
      "tauriInvoke": "webui_get_models_metadata",
      "category": "misc",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/webui/models-metadata"
      },
      "input": null,
      "output": "ModelsMetadata",
      "errorCases": [
        {
          "status": 502,
          "description": "Upstream models.dev error"
        },
        {
          "status": 504,
          "description": "Upstream timeout"
        }
      ],
      "notes": "Reuse existing cache semantics; consider Tauri-side memoization."
    },
    {
      "name": "config.getAgent",
      "tauriInvoke": "config_get_agent",
      "category": "agents",
      "priority": "high",
      "http": {
        "method": "GET",
        "path": "/api/config/agents/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        }
      },
      "output": "AgentSourceSummary",
      "errorCases": [
        {
          "status": 500,
          "description": "Failed to read agent configuration"
        }
      ],
      "notes": "No restart required; read-only."
    },
    {
      "name": "config.createAgent",
      "tauriInvoke": "config_create_agent",
      "category": "agents",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/config/agents/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        },
        "bodyType": "AgentWritePayload"
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Filesystem write failure or duplicate agent"
        }
      ],
      "notes": "Triggers OpenCode restart; desktop app must gate UI until reloadDelayMs elapses."
    },
    {
      "name": "config.updateAgent",
      "tauriInvoke": "config_update_agent",
      "category": "agents",
      "priority": "high",
      "http": {
        "method": "PATCH",
        "path": "/api/config/agents/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        },
        "bodyType": "AgentWritePayload"
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Update failed due to invalid field or IO error"
        }
      ],
      "notes": "Preserves markdown/frontmatter precedence; restarts OpenCode."
    },
    {
      "name": "config.deleteAgent",
      "tauriInvoke": "config_delete_agent",
      "category": "agents",
      "priority": "high",
      "http": {
        "method": "DELETE",
        "path": "/api/config/agents/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        }
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Deletion failed"
        }
      ],
      "notes": "Requires elevated file permissions; restarts OpenCode."
    },
    {
      "name": "config.getCommand",
      "tauriInvoke": "config_get_command",
      "category": "config",
      "priority": "high",
      "http": {
        "method": "GET",
        "path": "/api/config/commands/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        }
      },
      "output": "CommandSourceSummary",
      "errorCases": [
        {
          "status": 500,
          "description": "Failed to read command configuration"
        }
      ],
      "notes": "Read-only; no restart."
    },
    {
      "name": "config.createCommand",
      "tauriInvoke": "config_create_command",
      "category": "config",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/config/commands/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        },
        "bodyType": "CommandWritePayload"
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Filesystem write failure or duplicate command"
        }
      ],
      "notes": "Restarts OpenCode; reuse reloadDelayMs for UI gating."
    },
    {
      "name": "config.updateCommand",
      "tauriInvoke": "config_update_command",
      "category": "config",
      "priority": "high",
      "http": {
        "method": "PATCH",
        "path": "/api/config/commands/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        },
        "bodyType": "CommandWritePayload"
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Update failed"
        }
      ],
      "notes": "Restarts OpenCode; ensure optimistic UI handles pending state."
    },
    {
      "name": "config.deleteCommand",
      "tauriInvoke": "config_delete_command",
      "category": "config",
      "priority": "high",
      "http": {
        "method": "DELETE",
        "path": "/api/config/commands/:name"
      },
      "input": {
        "pathParams": {
          "name": "string"
        }
      },
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "Deletion failed"
        }
      ],
      "notes": "Restarts OpenCode."
    },
    {
      "name": "config.reloadOpenCode",
      "tauriInvoke": "config_reload_opencode",
      "category": "system",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/config/reload"
      },
      "input": null,
      "output": "ReloadResponse",
      "errorCases": [
        {
          "status": 500,
          "description": "OpenCode restart failed"
        }
      ],
      "notes": "Direct control for manual restarts; surface logs in desktop UI."
    },
    {
      "name": "gitIdentities.list",
      "tauriInvoke": "git_identities_list",
      "category": "config",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/identities"
      },
      "input": null,
      "output": "GitIdentity[]",
      "errorCases": [
        {
          "status": 500,
          "description": "Failed to read git identities file"
        }
      ],
      "notes": "Persist identities locally for offline availability."
    },
    {
      "name": "gitIdentities.create",
      "tauriInvoke": "git_identities_create",
      "category": "config",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/git/identities"
      },
      "input": {
        "bodyType": "GitIdentityWritePayload"
      },
      "output": "GitIdentity",
      "errorCases": [
        {
          "status": 400,
          "description": "Duplicate id or missing required fields"
        },
        {
          "status": 500,
          "description": "Failed to persist git identities file"
        }
      ],
      "notes": "Consider Tauri-side validation before invoking."
    },
    {
      "name": "gitIdentities.update",
      "tauriInvoke": "git_identities_update",
      "category": "config",
      "priority": "medium",
      "http": {
        "method": "PUT",
        "path": "/api/git/identities/:id"
      },
      "input": {
        "pathParams": {
          "id": "string"
        },
        "bodyType": "GitIdentityUpdatePayload"
      },
      "output": "GitIdentity",
      "errorCases": [
        {
          "status": 400,
          "description": "Profile not found"
        }
      ],
      "notes": "Write-through to git-identities.json."
    },
    {
      "name": "gitIdentities.delete",
      "tauriInvoke": "git_identities_delete",
      "category": "config",
      "priority": "medium",
      "http": {
        "method": "DELETE",
        "path": "/api/git/identities/:id"
      },
      "input": {
        "pathParams": {
          "id": "string"
        }
      },
      "output": "GenericSuccess",
      "errorCases": [
        {
          "status": 400,
          "description": "Profile not found or deletion failed"
        }
      ],
      "notes": "Update local cache post-delete."
    },
    {
      "name": "git.getGlobalIdentity",
      "tauriInvoke": "git_get_global_identity",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/global-identity"
      },
      "input": null,
      "output": "Record<string, string | null>",
      "errorCases": [],
      "notes": "Relies on git CLI; ensure it exists in Tauri bundle."
    },
    {
      "name": "git.checkRepository",
      "tauriInvoke": "git_check_repository",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/check"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        }
      },
      "output": "{ isGitRepository: boolean }",
      "errorCases": [
        {
          "status": 400,
          "description": "directory query missing"
        }
      ],
      "notes": "Pure filesystem check; safe to call frequently."
    },
    {
      "name": "git.getCurrentIdentity",
      "tauriInvoke": "git_get_current_identity",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/current-identity"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        }
      },
      "output": "Record<string, string | null>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory query missing"
        }
      ],
      "notes": "Falls back to global identity when local values absent."
    },
    {
      "name": "git.setIdentity",
      "tauriInvoke": "git_set_identity",
      "category": "projects",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/git/set-identity"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitIdentityApplyPayload"
      },
      "output": "{ success: true; profile: GitIdentity }",
      "errorCases": [
        {
          "status": 400,
          "description": "Missing directory or profileId"
        },
        {
          "status": 404,
          "description": "Profile not found"
        },
        {
          "status": 500,
          "description": "Git config update failed"
        }
      ],
      "notes": "Requires git CLI; may prompt for credentials depending on sshKey usage."
    },
    {
      "name": "git.getStatus",
      "tauriInvoke": "git_get_status",
      "category": "projects",
      "priority": "high",
      "http": {
        "method": "GET",
        "path": "/api/git/status"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        }
      },
      "output": "GitStatus",
      "errorCases": [
        {
          "status": 400,
          "description": "directory query missing"
        },
        {
          "status": 500,
          "description": "Git command failed"
        }
      ],
      "notes": "Expected to be polled when repo view is active."
    },
    {
      "name": "git.pull",
      "tauriInvoke": "git_pull",
      "category": "projects",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/git/pull"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitRemoteOptions"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        },
        {
          "status": 500,
          "description": "Git pull failure"
        }
      ],
      "notes": "Ensure background thread to avoid blocking Tauri main process."
    },
    {
      "name": "git.push",
      "tauriInvoke": "git_push",
      "category": "projects",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/git/push"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitRemoteOptions"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        },
        {
          "status": 500,
          "description": "Git push failure"
        }
      ],
      "notes": "Surface stdout/stderr in UI for troubleshooting."
    },
    {
      "name": "git.fetch",
      "tauriInvoke": "git_fetch",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/git/fetch"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitRemoteOptions"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        }
      ],
      "notes": "Non-destructive; can run in background."
    },
    {
      "name": "git.commit",
      "tauriInvoke": "git_commit",
      "category": "projects",
      "priority": "high",
      "http": {
        "method": "POST",
        "path": "/api/git/commit"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitCommitPayload"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory or message missing"
        },
        {
          "status": 500,
          "description": "Git commit failure"
        }
      ],
      "notes": "Optionally stage all changes when addAll true."
    },
    {
      "name": "git.listBranches",
      "tauriInvoke": "git_list_branches",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/branches"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        }
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        }
      ],
      "notes": "Response mirrors simple-git branch summary."
    },
    {
      "name": "git.createBranch",
      "tauriInvoke": "git_create_branch",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/git/branches"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitBranchCreatePayload"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "Missing directory or branch name"
        },
        {
          "status": 500,
          "description": "Git branch creation failed"
        }
      ],
      "notes": "Prefer to refresh branch list after invocation."
    },
    {
      "name": "git.checkoutBranch",
      "tauriInvoke": "git_checkout_branch",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/git/checkout"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitCheckoutPayload"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "Missing directory or branch name"
        },
        {
          "status": 500,
          "description": "Git checkout failed"
        }
      ],
      "notes": "Consider blocking UI during checkout to avoid conflicts."
    },
    {
      "name": "git.listWorktrees",
      "tauriInvoke": "git_list_worktrees",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/worktrees"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        }
      },
      "output": "GitWorktreeEntry[]",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        }
      ],
      "notes": "Parse porcelain output; convert relative paths to absolute if needed in UI."
    },
    {
      "name": "git.addWorktree",
      "tauriInvoke": "git_add_worktree",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/git/worktrees"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitWorktreeCreatePayload"
      },
      "output": "Record<string, unknown>",
      "errorCases": [
        {
          "status": 400,
          "description": "Missing directory, path, or branch"
        },
        {
          "status": 500,
          "description": "Git worktree add failed"
        }
      ],
      "notes": "Paths must be sanitized client-side to avoid escape."
    },
    {
      "name": "git.removeWorktree",
      "tauriInvoke": "git_remove_worktree",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "DELETE",
        "path": "/api/git/worktrees"
      },
      "input": {
        "queryParams": {
          "directory": "string"
        },
        "bodyType": "GitWorktreeRemovePayload"
      },
      "output": "GenericSuccess",
      "errorCases": [
        {
          "status": 400,
          "description": "Missing directory or path"
        },
        {
          "status": 500,
          "description": "Git worktree removal failed"
        }
      ],
      "notes": "Force flag triggers --force."
    },
    {
      "name": "git.getLog",
      "tauriInvoke": "git_get_log",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "GET",
        "path": "/api/git/log"
      },
      "input": {
        "queryParams": {
          "directory": "string",
          "maxCount": "number?",
          "from": "string?",
          "to": "string?",
          "file": "string?"
        }
      },
      "output": "GitLogResponse",
      "errorCases": [
        {
          "status": 400,
          "description": "directory missing"
        }
      ],
      "notes": "Consider streaming large logs to avoid blocking."
    },
    {
      "name": "fs.mkdir",
      "tauriInvoke": "fs_mkdir",
      "category": "projects",
      "priority": "medium",
      "http": {
        "method": "POST",
        "path": "/api/fs/mkdir"
      },
      "input": {
        "bodyType": "MkdirPayload"
      },
      "output": "GenericSuccess",
      "errorCases": [
        {
          "status": 400,
          "description": "Invalid path or traversal attempt"
        },
        {
          "status": 500,
          "description": "Directory creation failed"
        }
      ],
      "notes": "Consider replacing with direct Tauri FS API in desktop build."
    }
  ],
  "excludedRoutes": [
    {
      "path": "/api/*",
      "method": "ALL",
      "reason": "Proxy middleware should be replaced by direct OpenCode SDK calls inside the Tauri app."
    },
    {
      "path": "/^(?!/api).*$/",
      "method": "GET",
      "reason": "Static file serving handled by Tauri bundler instead of Express."
    },
    {
      "path": "proxy-server.js/*",
      "method": "ALL",
      "reason": "Standalone CORS proxy script not needed in desktop app."
    }
  ],
  "considerations": [
    "Git operations depend on system git binary; ensure Tauri runtime can invoke it and capture stdout/stderr.",
    "OpenCode restarts (config mutations) can interrupt the SDK AsyncGenerator SSE stream; desktop should buffer UI updates until health checks pass.",
    "Config mutation endpoints (agents/commands) write to user configuration directories; map to Tauri-safe storage paths if sandboxed.",
    "Prefer to reuse existing OpenCode SDK for proxied calls instead of forwarding HTTP through Express in the desktop build."
  ]
}